问：下面shell

/usr/bin/sed -e "s:/root/beegfs:/mnt/beegfs:g" /root/beegfs/920016/query.600 >>/root/beegfs/920016/query.600_999

cat  /root/beegfs/920016/query.600_999 |  beegfs-ctl --getentryinfo  -  //报错，不是命令有问题 自己手工插入同样数据就没问题 



请问下面命令有什么不同 ，getentryinfo 是tcp短连接，命令2 出现很多time_wait ,应该是一个输入 一个进程，命令1不是？
命令1 cat /root/beegfs/920016/query.600_999 |xargs  -n1 | beegfs-ctl --getentryinfo --verbose -  // TIME_WAIT 0
命令2 cat /root/beegfs/920016/query.600_999 | xargs -n1 -I {} sh -c "echo {} && /usr/bin/beegfs-ctl --getentryinfo  {}"  //TIME_WAIT 5000

https://maimai.cn/web/gossip_detail?encode_id=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlZ2lkIjoiNmMxMzJhYWE5MzhmNGUzNmE2YjdiZWU5NGM2MTUxNmMiLCJpZCI6MzA4NzYzMzMsInUiOjQ2NjUxfQ.wsKdpE2UUkorjYsQn69IeHyMR7YrHiNI_1z3lwqVQjU&from=list
 

tail -f beegfs_migration.log  |grep get_poolId_from_response



1、这个让李永杰明确一下
2、这个还涉及测试验证
3、如果合并做，代码最好一套，用不同参数区分


1、相同点：功能上只有全量扫描代码可服用。
2、不同点：中移场景是不同集群迁移，涉及软连接等
3、新增需求是否需要增加开发人员。对应产品经理
4、中移动迁移是否加入DiLuV2? (找李永杰明确)
	 如果合并做，代码最好一套，用不同参数区分
 
5、详细列出中移动需求---赵
6、评估中移动工作量--赵
7、UI需求---赵





如果合并做，代码最好一套，用不同参数区分

缺失的UI设计等部分



1. 优先满足客户需求，如果客户需要UI等,需要实现
2. 目前没有缺少UI设计人员，找xx协议
 Dilu V2数据分层概要设计
开发周期待评估

概要缺失部分



在产品规格，故障处理 和版本规划上 给出具体的改进建议
功能缺失部门



给出改进 完善建议


改进意见

协助

争议

，未迁移走的数据，并多次迁移
5、我们当前可以运行如下命令查询下有多少文件是放在坏target上
find /mnt/beegfs -type f | beegfs-ctl --getentryinfo --verbose - > /tmp/entryinfo.txt

/usr/bin/beegfs-ctl  --getentryinfo /mnt/beegfs/6/vdb.1_1.dir/vdb.2_3.dir/vdb.3_2.dir/vdb.4_2.dir/vdb_f293063.file

find /mnt/beegfs -type f | beegfs-ctl --getentryinfo --verbose - 



find /mnt/beegfs -type f | beegfs-ctl --getentryinfo --verbose -  /mnt/beegfs/6/vdb.1_1.dir/vdb.2_3.dir/vdb.3_2.dir/vdb.4_2.dir/vdb_f293063.file



[root@h12-storage03 log]# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'

/usr/bin/beegfs-ctl  --getentryinfo /mnt/beegfs/6/vdb.1_1.dir/vdb.2_3.dir/vdb.3_1.dir/vdb.4_1.dir/vdb_f33551.file


root@h12-storage03 beegfs]# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
ESTABLISHED 110
FIN_WAIT1 1
SYN_SENT 1
TIME_WAIT 5000

短连接最大的优点是方便，特别是脚本语言，由于执行完毕后脚本语言的进程就结束了，基本上都是用短连接。
但短连接最大的缺点是将占用大量的系统资源，例如：本地端口、socket句柄。
导致这个问题的原因其实很简单：tcp协议层并没有长短连接的概念，因此不管长连接还是短连接，连接建立->数据传输->连接关闭的流程和处理都是一样的。
————————————————
版权声明：本文为CSDN博主「华仔爱技术」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yunhua_lee/article/details/8146830
netstat -n |grep TIME_WAIT

如何获取TIME_WAIT端口号进程

tcp        0      0 10.141.162.45:27460     10.141.162.40:8008      TIME_WAIT
10.141.162.40:8008      ESTABLISHED 2422319/beegfs-meta



watch -n 5 -d   netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
ESTABLISHED 98
SYN_SENT 1
TIME_WAIT 5421

分类计数统计 本机8080端口下 TIME_WAIT状态的tcp链接 的目的主机是哪些机器
ss -natr | grep TIME-WAIT | grep 8080 | awk '{print $5}'| cut -d . -f1|sed "s/[0-9]*$//g" |sort |uniq -c |sort -nr
ss -natr | grep TIME-WAIT | awk '{print $5}'| cut -d . -f1|sed "s/[0-9]*$//g" |sort |uniq -c |sort -nr

10.141.162.40:8005      10.141.162.45:53452     ESTABLISHED 2422319/beegfs-meta


[root@h12-storage01 ~]# ss -s
Total: 415
TCP:   57320 (estab 93, closed 57211, orphaned 0, timewait 57211)

Transport Total     IP        IPv6
RAW       1         0         1
UDP       9         7         2
TCP       109       107       2
INET      119       114       5
FRAG      0         0         0


62700  62460  99%    0.27K   1045       60     16720K tw_sock_TCP


当最后一个ACK丢失时,远程连接进入LAST-ACK状态,它可以确保远程已经关闭当前TCP连接。
如果没有TIME-WAIT

状态,当远程仍认为这个连接是有效的,则会继续与其通讯,导致这个连接会被重新打开。当远程收到一个SYN 时,会回复
一个RST包,因为这SEQ不对,那么新的连接将无法建立成功,报错终止



/usr/bin/beegfs-ctl  --migrate   --storagepoolid=3 --destinationpoolid=1 /mnt/beegfs/6/vdb.1_4.dir/vdb.2_3.dir/vdb.3_3.dir/vdb.4_4.dir/vdb_f1003861.file

/usr/bin/beegfs-ctl  --getentryinfo /mnt/beegfs/6/vdb.1_4.dir/vdb.2_3.dir/vdb.3_3.dir/vdb.4_4.dir/vdb_f1003861.file

 sysctl -p



vi /etc/sysctl.conf
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.ip_local_port_range = 3500 65535
net.ipv4.tcp_max_syn_backlog = 16384
fs.aio-max-nr=1048576
net.core.somaxconn = 2048
net.core.netdev_max_backlog = 10000
net.core.rmem_default = 16777216
net.core.wmem_default = 16777216
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.somaxconn = 2048

net.core.netdev_max_backlog = 10000
net.core.rmem_default = 16777216
net.core.wmem_default = 16777216
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

sysctl -p



net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

net.ipv4.tcp_fin_timeout = 30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。

net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。

net.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。

net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_tw_buckets = 5000表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。


https://ask.oceanbase.com/t/topic/13700373/3

https://www.cnblogs.com/my-show-time/p/15206020.html

net.core.somaxconn是Linux中的一个内核(kernel)参数，表示socket监听(listen)的backlog上限。
什么是backlog？backlog就是 socket的监听队列，当一个请求(request)尚未被处理或者建立时，它就会进入backl


[root@h12-storage01 .temp_beegfs_migration]# cat query.6  |wc -l
87000

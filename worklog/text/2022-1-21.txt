template <class _Ty>
class _Ref_count : public _Ref_count_base { // handle reference counting for pointer without deleter
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    void _Destroy() noexcept override { // destroy managed resource
        delete _Ptr;
    }

    void _Delete_this() noexcept override { // destroy self
        delete this;
    }

    _Ty* _Ptr;
};

_Set_ptr_rep_and_enable_shared

  make_shared(_Types&&... _Args) { // make a shared_ptr to non-array object
    const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);
	
 template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { // take ownership of _Px
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }
	

template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { // take ownership of _Px
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }
	
	
make_shared(_Types&&... _Args) { // make a shared_ptr to non-array object
    const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
	
	
template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { // handle reference counting for object in control block, no allocator
public:
    //????
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

            _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);
        }
    }
	//？？？？？

};

git reset --hard HEAD^


如何下载哔哩哔哩的视频
1. 哔哩下载姬
https://github.com/leiurayer/downkyi

2 pip install you-get
3. Python+tkinter
https://www.52pojie.cn/thread-1203083-1-1.html

http://127.0.0.1:8080/readmp4?path=D:\mp4\2022\bb\手把手深度剖析leveldb源码(第三部分)\leveldb SST数据结构讲解_高清 1080P.mp4

python -V
github密码
Qwer@13578


1.引流:不同平台一键推广
2、视频录制与存储。

1 禅道 ok
2 考勤
3 李岚16
4 删帖
5 自我介绍

大家好，我后台开发一枚，拥有6年c++开发调优经验，
受限于公司业务，想通过开源寻找更多喜欢研究的小伙伴提高视野，
或者帮助有需要的小伙伴。

6 静态图像转虚拟主播动画


stream账号
redismdb
xiaowangGo2022

盐值达到 640 分的用户
https://www.zhihu.com/appview/level-detail

https://www.python.org/downloads/release/python-3102/
%USERPROFILE%\AppData\Local\Microsoft\WindowsApps

pip 是首选的安装程序。
从Python 3.4开始，它默认包含在Python二进制安装程序中。
D:\local\Python\Python310\Scripts

pip 安装第三方库路径：
D:\local\Python\Python310\Lib\site-packages

ERROR: Cannot install ppgan==0.1.3, ppgan==2.0.0 and ppgan==2.1.0 because these package versions have conflicting dependencies.

  Downloading http://mirrors.aliyun.com/pypi/packages/8a/2d/4ebc291d8fca24d8e766948aa2192f38128f715f645a651e328f46a76f28/ppgan-0.1.1-py3-none-any.whl (3.6 kB)
ERROR: Cannot install ppgan==0.1.3, ppgan==2.0.0 and ppgan==2.1.0 because these package versions have conflicting dependencies.

The conflict is caused by:
    ppgan 2.1.0 depends on numba==0.53.1
    ppgan 2.0.0 depends on numba==0.48
    ppgan 0.1.3 depends on numba==0.48

To fix this you could try to:
1. loosen the range of package versions you've specified
2. remove package versions to allow pip attempt to solve the dependency conflict

ERROR: ResolutionImpossible: for help visit https://pip.pypa.io/en/latest/user_guide/#fixing-conflicting-dependencies
remove package versions to allow pip attempt to solve the dependency conflict




百度PaddlePaddle
      WARNING: The repository located at mirrors.aliyun.com is not a trusted or secure host and is being ignored. If this repository is available via HTTPS we recommend you use HTTPS instead, otherwise you may silence this warning and allow it anyway with '--trusted-host mirrors.aliyun.com'.
      ERROR: Could not find a version that satisfies the requirement numpy>=1.11 (from versions: none)
      ERROR: No matching distribution found for numpy>=1.11
Using legacy 'setup.py install' for librosa, since package 'wheel' is not installed.
Using legacy 'setup.py install' for numba, since package 'wheel' is not installed.
Using legacy 'setup.py install' for easydict, since package 'wheel' is not installed.
Using legacy 'setup.py install' for audioread, since package 'wheel' is not installed.
Using legacy 'setup.py install' for llvmlite, since package 'wheel' is not installed.
Using legacy 'setup.py install' for resampy, since package 'wheel' is not installed.

pip install wheel
Successfully installed wheel-0.37.1
pip install numpy
Successfully installed numpy-1.22.2
pip install numba



pip install ppgan
  note: This error originates from a subprocess, and is likely not a problem with pip.
  ERROR: Failed building wheel for numba
  
  pip install ppgan
    ERROR: Failed building wheel for numba
	
	   numba/_dispatcher.c(26): error C2039: "use_tracing": 不是 "_ts" 的成员
      D:\local\Python\Python310\include\cpython/pystate.h(60): note: 参见“_ts”的声明
      numba/_dispatcher.c(28): error C2039: "use_tracing": 不是 "_ts" 的成员
      D:\local\Python\Python310\include\cpython/pystate.h(60): note: 参见“_ts”的声明
      numba/_dispatcher.c(199): warning C4244: “=”: 从“Py_ssize_t”转换到“int”，可能丢失数据
      numba/_dispatcher.c(301): error C2039: "use_tracing": 不是 "_ts" 的成员
      D:\local\Python\Python310\include\cpython/pystate.h(60): note: 参见“_ts”的声明
      numba/_dispatcher.c(507): error C2039: "use_tracing": 不是 "_ts" 的成员
      D:\local\Python\Python310\include\cpython/pystate.h(60): note: 参见“_ts”的声明
      numba/_dispatcher.c(517): warning C4244: “=”: 从“Py_ssize_t”转换到“int”，可能丢失数据
      error: Command "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\bin\HostX86\x64\cl.exe /c /nologo /Ox /W3 /GL /DNDEBUG /MD -ID:\\local\\Python\\Python310\\lib\\site-packages\\numpy\\core\\include -ID:\local\Python\Python310\include -ID:\local\Python\Python310\Include -IC:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\ATLMFC\include -IC:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\include -IC:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt -IC:\Program Files (x86)\Windows Kits\10\\include\10.0.19041.0\\shared -IC:\Program Files (x86)\Windows Kits\10\\include\10.0.19041.0\\um -IC:\Program Files (x86)\Windows Kits\10\\include\10.0.19041.0\\winrt -IC:\Program Files (x86)\Windows Kits\10\\include\10.0.19041.0\\cppwinrt /Tcnumba/_dispatcher.c /Fobuild\temp.win-amd64-3.10\Release\numba/_dispatcher.obj" failed with exit status 2
      [end of output]
	 
	 pip install numba==0.55.0rc1
百度飞桨PaddleSpeech
18

0001 0010

30 22 * * * sh /root/daily-interview/a.sh

C:\Users\wangchuanyi/.ssh/id_rsa1

ssh root@192.168.75.131 -A

sudo yum install epel-release
sudo yum install snapd
sudo systemctl enable --now snapd.socket
sudo ln -s /var/lib/snapd/snap /snap
sudo snap install massif-visualizer --edge
go tool pprof -http=":9998" 192.168.75.131:9999/debug/pprof/heap
http://192.168.75.131:9998/ui

http://192.168.75.131:9999/debug/pprof/heap


13780668391,18669816811,13061300659

pstack是/usr/bin/gstack的软链接, 而gstack本身是基于gdb封装的shell脚本
backtrace="thread apply all bt"
 在linux的根目录下存在一个/proc目录，/proc文件系统是一种虚拟文件系统,以文件系统目录和文件形式,提供一个指向内核数据结构的接口
 
 
 show parameters like 'trace_log_slow%';
 看一个模块
 看一个模块
 看一个模块
 
 
(gdb) disassemble  main
Dump of assembler code for function main:
   0x00000000004005f8 <+0>:     push   %rbp
   0x00000000004005f9 <+1>:     mov    %rsp,%rbp
   0x00000000004005fc <+4>:     mov    $0x4006fc,%edi
   0x0000000000400601 <+9>:     callq  0x400468 <puts@plt>
   0x0000000000400606 <+14>:    mov    $0x0,%eax
   0x000000000040060b <+19>:    pop    %rbp
   0x000000000040060c <+20>:    retq
End of assembler dump.
(gdb) disassemble 0x400468
Dump of assembler code for function puts@plt:
   0x0000000000400468 <+0>:     jmpq   *0x200542(%rip)        # 0x6009b0 <puts@got.plt>
   0x000000000040046e <+6>:     pushq  $0x0
   0x0000000000400473 <+11>:    jmpq   0x400458
End of assembler dump.
(gdb) x/x 0x400458
0x400458:       0x054235ff
(gdb) x/x  0x6009b0
0x6009b0 <puts@got.plt>:        0x0040046e

如果一个动态库函数是第一次被调用，那么plt表中是不存在该函数的地址的，通过ld库中的函数，
将这个地址取出来存放到got表中，
那么当第二次调用该函数时，plt表中就有了这个函数的地址，直接跳转到该地址，
而不再需要去取地址，也就是动态链接。
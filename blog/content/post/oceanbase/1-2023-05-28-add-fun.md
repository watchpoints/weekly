---
title: "成为oceanbase贡献者第四天：内置函数"
date: 2023-05-26
description: "自我驱动学习，专业上只能靠自己"
draft: false
categories: ["oceanbase"]
---





# #一、Overview 



大家好， 本文主要描述是如何OceanBase 社区版实现一个 MySQL 5.7 新增的系统内建函数。

思考 60秒，可能会产生下面几个疑问。





- 新增一个表达式 ，需要修改parser模块吗？



单元测试如何执行一个sql命令？



**如何上手**

可以参考当前已有的实现，比如ST_area。

主要参考代码文件 

ob_expr_st_area.cpp.h 

ob_expr_st_area.h

ob_geo_func_area.cpp/.h

ob_geo_func_register.h

问题：

ST_area 函数实现，并没有在ObExprOperatorFactory::register_expr_operators 注册？和普通表达式实现不一样吗、





![](https://img-blog.csdnimg.cn/img_convert/813fe3b29417a79cdaf369b19161f479.png)

# 二、 Solutions



涉及文件：

- ob_sql.cpp:2425
- ob_dml_resolver.cpp:1589
- ob_select_resolver.cpp:1859
- ob_select_resolver.cpp:1274

### sql 客户端



| ST_Area({poly | mpoly}) | 计算多边形的面积，参数可以是Polygon或者MultiPolygon，MultiPolygon的面积是其中所有多边形面积的和 |
| ------------- | ------- | ------------------------------------------------------------ |
|               |         |                                                              |

~~~sql
https://dev.mysql.com/doc/refman/5.7/en/gis-polygon-property-functions.html#function_area
mysql> SET @poly =
       'Polygon((0 0,0 3,3 0,0 0),(1 1,1 2,2 1,1 1))';
mysql> SELECT ST_Area(ST_GeomFromText(@poly));
+---------------------------------+
| ST_Area(ST_GeomFromText(@poly)) |
+---------------------------------+
|                               4 |
+---------------------------------+

mysql> SET @mpoly =
       'MultiPolygon(((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2 1,1 1)))';
mysql> SELECT ST_Area(ST_GeomFromText(@mpoly));
+----------------------------------+
| ST_Area(ST_GeomFromText(@mpoly)) |
+----------------------------------+
|                                8 |
+----------------------------------+
~~~









### parser模块

>  表达式是如何被解析的

Parser 是整个 SQL 执行引擎的词法或语法解析器。通过flex（ 词法分析器生成工具） 和bison(语法分析器生成器) 通过把 SQL 字符串解析为一个 ParseNode 组成的抽象语法树。

用法参考：miniob-sql-parser.md

相关代码：

- ob_parser.cpp

- sql_parser_mysql_mode.l
- sql_parser_mysql_mode.y



### resolver模块 

ObDMLResolver::resolve_sql_expr

`ObDMLResolver::resolve_sql_expr`函数：	

- 功能：该函数用于解析SQL表达式并生成对应的`ObRawExpr`对象，同时进行一系列的解析和分析操作，

  ​     包括解析函数、解析列、解析系统变量等。

- 输入参数：

  - `const ParseNode &node`：要解析的 SQL 表达式的语法节点。
  - `ObRawExpr *&expr`：解析后的表达式树的指针，通过该参数返回。
  - `ObArray<ObQualifiedName> *output_columns`：可选参数，用于存储解析过程中发现的列名信息。



### resolver模块 

> 判断st_area函数是否存在

表达式解析类是位于sql/resolver/expr 的ObRawExprResolver，它输入ObParseNode 树，输出表达式树 ObRawExpr 。

这个 ObRawExpr 仅用于优化器阶段的语义分析优化，在生成物理执行计划后会被转换为为执行效率优化的 ObExpr 。

文件：D:\db\oceanbase\src\sql\resolver\expr\ob_raw_expr_resolver_impl.cpp





1. 根据节点的类型：case T_FUN_SYS:，执行process_fun_sys_node和process_dll_udf_node(udf其他特殊类型的函数这里跳过)

- ObRawExprResolverImpl::process_fun_sys_node(const ParseNode *node, ObRawExpr *&expr)

​    在递归解析参数列表之前, 先检查下当前函数是否存在, 这是因为如果该函数报错          OB_ERR_FUNCTION_UNKNOWN, 外部会继续尝试是否是UDF、



2. 根据函数名字查找类型type = ObExprOperatorFactory::get_type_by_name(func_name);

- ObExprOperatorType ObExprOperatorFactory::get_type_by_name(const ObString &name)

  

### 表达式注册

> ob_expr_operator_factory.cpp  ObExprSTArea函数是如何被注册的？

执行过程分析

1. ObExprSTArea op(alloc) //构造函数，虽然只有一个参数，但是继承关系，默认 函数名字和类型写死了。



2. 表达式名字： st_area，表达式类型 T_FUN_SYS_ST_AREA 1676

\#define N_ST_AREA                           "st_area"

T_FUN_SYS_ST_AREA = 1676,

sql 命令 关联函数执行

1. REG_OP 实现是一个 lambda表达式，通过引用的方式捕获 获取外部变量：

​     其中 i ,alloc,NAME_TYPES 含义 表达式个数，分配器类型和全局静态数组

​      ObExprOperatorFactory::register_expr_operators()





- 对照代码 ObExprOperatorFactory::register_expr_operators()

```c++
void ObExprOperatorFactory::register_expr_operators()
{
  memset(NAME_TYPES, 0, sizeof(NAME_TYPES));
  ObArenaAllocator alloc;
  int64_t i = 0; //
  REG_OP(ObExprSTArea);//注册表达式，这里面是lambda表达式
}
    
ObExprOperatorFactory::NameType ObExprOperatorFactory::NAME_TYPES[EXPR_OP_NUM] = { };

#define REG_OP(OpClass)                             \
  do { //lambda 语法，[&] 按引用的方式捕获所有外部变量。                                             \
    [&]() {                                         \
      OpClass op(alloc);  // ObExprSTArea(common::ObIAllocator &alloc);                        \
      if (OB_UNLIKELY(i >= EXPR_OP_NUM)) {          \
        LOG_ERROR("out of the max expr");           \
      } else {                                      \
        NAME_TYPES[i].name_ = op.get_name();        \   //外部变量   位置register_expr_operators 
        NAME_TYPES[i].type_ = op.get_type();        \
        NAME_TYPES[i].is_internal_ = op.is_internal_for_mysql(); \
        OP_ALLOC[op.get_type()] = ObExprOperatorFactory::alloc<OpClass>; \
        i++;  //外部变量   位置register_expr_operators                                     \
      }                                             \
    }();                                            \
  } while(0) //只执行一次就结束 理解成if

```



> 旁白：

- lambda本质就是 函数对象，在stl源码解析book有解释 函数对象：opeartor ()的一个类. 
- lambda 语法，**[&]** 按引用的方式捕获所有外部变量。
- **define是在预处理中进行替换，const语句是实实在在的编译器处理的**
- 

### engine/expr 

#### ObExprSTArea::eval_st_area是如何实现的

1. 在ObExpr::EvalFunc g_expr_eval_functions 添加新的计算函数

​       ObExprSTArea::eval_st_area,                                         /* 557 */

2. ObExprSTArea::eval_st_area 函数 
3.    调用 Making Use of Boost Geometry in MySQL GIS

- https://www.boost.org/doc/libs/1_78_0/libs/geometry/doc/html/index.html



# 第三部分：coding 



修改文件





- D:\db\oceanbase\deps\oblib\src\lib\CMakeLists.txt

- D:\db\oceanbase\deps\oblib\src\lib\geo\ob_geo_func_exterior_ring.cpp

  

- D:\db\oceanbase\src\sql\CMakeLists.txt

- D:\db\oceanbase\src\sql\engine\expr\ob_expr_operator_factory.cpp

- D:\db\oceanbase\deps\oblib\src\lib\ob_name_def.h

- D:\db\oceanbase\src\sql\engine\expr\ob_expr_st_exterior_ring.cpp

  

- D:\db\oceanbase\unittest\share\CMakeLists.txt

- oblib\src\lib\CMakeLists.txt

  

  

  





## ST_ExteriorRing实现过程

### 构建环境

~~~shell
# 查看本地磁盘，在上面构建编译的环境（vmare虚拟机）
lsblk 
# 格式化
mkfs.ext4 /dev/nvme0n3 
mkfs.ext4 /dev/nvme0n5
mount /dev/nvme0n3 /mnt/oceanbase/
mount /dev/nvme0n5 /mnt/ob
# DEBUG 构建
bash build.sh debug --init

git config user.name  watchpoints
git config user.email wang_cyi@163.com
如果你用Windows就设置全局变量 
git config --global core.autocrlf true 
如果是mac/linux则设置 
git config --global core.autocrlf input 
 如果使用 set list 显示隐藏字符 : set nolist ：不显示


## 关联远程仓库，保证代码可以和远程更新和提交
git remote add oceanbase https://github.com/oceanbase/oceanbase.git
git remote -v
#把远程仓库最新的代码及分支拉取一下 [可以在界面手工合并]
git fetch oceanbase 
git merge oceanbase/master

## 本地创建分支，进行开发
https://github.com/oceanbase/oceanbase/issues/1400
git checkout -b issue_1400
git branch -a //git分支管理工具SourceTree
# git删除远程分支 清楚历史
git push origin --delete issue_1148

//创建 
obd cluster deploy watchpoints -c ./mini-local-example.yaml

obd cluster edit-config  watchpoints
obd cluster redeploy watchpoints  //这个是删除后重新安装。坑人
obd cluster reload watchpoints //重新加载obd配置文件 最少5G.4g不行
obd cluster stop watchpoints
obd cluster destroy watchpoints
obd cluster start watchpoints
//crash堆栈：addr2line -C -f -e + <observer二进制路径
https://ask.oceanbase.com/t/topic/35601536/6
free -g
echo 3 > /proc/sys/vm/drop_caches

tiup cluster stop watchpoints 
tiup cluster disable watchpoints 
obclient -h127.0.0.1 -P2881 -uroot -p'zb5VM0OpREorA520yzf7' -Doceanbase -A

为推送当前分支并建立与远程上游的跟踪，使用
 git push --set-upstream origin issue_1400
https://github.com/watchpoints/oceanbase/pull/new/issue_1400

tiup cluster disable watchpoints
obclient -h127.0.0.1 -P2881 -uroot -p'zb5VM0OpREorA520yzf7' -Doceanbase -A

cp /usr/local/bin/observer /mnt/ob/observer/bin/observer
obd cluster start watchpoints
obclient -h127.0.0.1 -P2881 -uroot -p'zb5VM0OpREorA520yzf7' -Doceanbase -A


https://dev.mysql.com/doc/refman/5.7/en/gis-polygon-property-functions.html#function_area
mysql> SET @poly =
       'Polygon((0 0,0 3,3 0,0 0),(1 1,1 2,2 1,1 1))';
mysql> SELECT ST_Area(ST_GeomFromText(@poly));
+---------------------------------+
| ST_Area(ST_GeomFromText(@poly)) |
+---------------------------------+
|                               4 |
+---------------------------------+

SELECT ST_ExteriorRing(ST_GeomFromText(@poly));

mysql> SET @mpoly =
       'MultiPolygon(((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2 1,1 1)))';
mysql> SELECT ST_Area(ST_GeomFromText(@mpoly));
+----------------------------------+
| ST_Area(ST_GeomFromText(@mpoly)) |
+----------------------------------+
|                                8 |
+----------------------------------+


mysql> SET @poly =
       'Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2 1,1 1))';
mysql> SELECT ST_AsText(ST_ExteriorRing(ST_GeomFromText(@poly)));
+----------------------------------------------------+
| ST_AsText(ST_ExteriorRing(ST_GeomFromText(@poly))) |
+----------------------------------------------------+
| LINESTRING(0 0,0 3,3 3,3 0,0 0)                    |
+----------------------------------------------------+

OceanBase参数配置建议(一)
https://mp.weixin.qq.com/s/lopg5ZbLO1w6v-SoVNs2Pg

 /root/.obd/repository/oceanbase-ce
 
~~~

### 单元测试

编译单元测试代码：

1. 在编译代码之前 修改 /mnt/oceanbase/oceanbase/unittest/share/CMakeLists.txt 文件 ，删除多余case

   只保留ob_unittest(test_geo_func_union) 

2.  重新构建bash build.sh debug --init（修改了CMAKE文件）

3.  cd /mnt/oceanbase/oceanbase/build_debug/unittest/share

   编译执行单元测试./test_geo_func_union

~~~
https://dev.mysql.com/doc/refman/5.7/en/gis-polygon-property-functions.html#function_st-exteriorring
Returns the exterior ring of the Polygon value poly as a LineString. If the argument is NULL or an empty geometry, 
test_geo_func_union.cpp
ObGeoEvalCtx gis_tree_context(&allocator);
  gis_tree_context.ut_set_geo_count(2);
  gis_tree_context.ut_set_geo_arg(0, poly_tree1);
  gis_tree_context.ut_set_geo_arg(1, poly_tree2);
  ObGeometry *result_tree = NULL;
  ret = ObGeoFunc<ObGeoFuncType::Union>::geo_func::eval(gis_tree_context, result_tree);
  ASSERT_EQ(OB_SUCCESS, ret);
  ASSERT_TRUE(result_tree != NULL);
  


~~~















##  第 四部分：可能遇到问题



提问1： FUNCTION ST_ExteriorRing does not exist

~~~
SELECT ST_ExteriorRing(ST_GeomFromText(@poly));
ERROR 1305 (42000): FUNCTION ST_ExteriorRing does not exist
st_exteriorring

~~~







#  # 他山之石

1. OceanBase 源码解读（十一）：表达式和函数

https://zhuanlan.zhihu.com/p/509650503

https://open.oceanbase.com/blog/8600156



Hello OceanBase！开启 OceanBase 二次开发

https://open.oceanbase.com/blog/10900229



OceanBase 源码解读（十二）：事务日志的提交和回放

https://zhuanlan.zhihu.com/p/484307311

2 https://www.yuque.com/yiyezhou/rgak0e/ykp9grn90kvx59c2

3. # Day2ofOceanBase

   https://www.yuque.com/yiyezhou/rgak0e/wb3leg】

   、

4. # TiFlash 表达式的实现与设计

   https://tidb.net/book/tidb-monthly/2022/2022-08/feature-indepth/tiflash-expression-design

   https://tidb.net/book/tidb-monthly/2022/2022-08/feature-indepth/tiflash-expression-design



# 慢慢来，多看、多问、多总结，肯定是可以攻克的。

文章地址：

http://localhost:1313/post/oceanbase/1-2023-05-28-add-fun

https://wangcy6.github.io/post/oceanbase/1-2023-05-28-add-fun

https://wangcy6.github.io/post/oceanbase/2022/oceanbase_day2/



### 沟通步骤

1. 准备好一个ppt，在写代码之前演示最终目标 和架构设计 就是如何去实现的 【不要说公司部门环境不对 着就是最终结果，不要试着看看，一定是可以完全上线的项目，非demo和一个知识点。自己认为真的 不是闹着玩的。。】

   一、这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题

   二、这个技术的优势和劣势分别是什么

   三、这个技术适用的场景。任何技术都有其适用的场景，离开了这个场景

   四、技术的组成部分和关键点。

   五、技术的底层原理和关键实现

   六、已有的实现和它之间的对比


2. 经过领导，专家 进行鸡蛋里挑骨头。【自己做好了别人路了胡扯，不会对别人产生任何影响，做事和做人一样，无论熟悉人，还是老师，领导，不相关人 反对 他们反馈信号，接受质疑，经过九九八十一难考验，并且你还在坚持认为对的。】

3. 最后融合别人建议，然后完善你项目。【不听老人言，吃亏在眼前，不敢接受别人批评，说明自己完全没有把握，才去否定 愤怒方式】


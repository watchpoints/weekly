---
title: "早起120小时写代码第一期：kvcore"
date: 2022-04-17
description: "早睡：21点准备 22点上床，早起 6点准备 ，8点-10点 120分钟"
draft: false
tags: ["60秒问答"]
---



#### day1： 2022-4-17 看斗鱼 看手机 晚上6点22点 时间规划和紧急措施陷入时间黑洞 #[象与骑象人](https://book.douban.com/subject/20260640//)，根本控制不大象，强制无效



[手写KV引擎(第一部分)-实现单机kv引擎](https://hardcore.feishu.cn/mindnotes/bmncnnOV8YnRi9CU04RZwhYGqte)

[【硬核课堂】LevelDB 源码分析](https://hardcore.feishu.cn/mindnotes/bmncnzpUmXNQruVGOwRwisHyxoh)



git clone git@github.com:wangcy6/coreKV-CPP.git

lesson05-sstable

https://hardcore.feishu.cn/docs/doccnjVdgWAfAEmg3g1HYqKvyhg







##### Lesson1.1 skiplist  

- 文档：https://hardcore.feishu.cn/docs/doccnPpGqZcPRpHwmSSGVUQhs5f
- 提问1：[面试官：为啥 redis 使用跳表(skiplist)而不是使用 red-black？](https://www.zhihu.com/question/20202931)



> Skip lists: a probabilistic alternative to balanced trees
>
> https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf



- . If p = 1/2, using MaxLevel = 16 is appropriate for data structures containing up to 216 elements.

​         

> 看java怎么实现的 

​      https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/ConcurrentSkipListMap.java

-  https://www.cl.cam.ac.uk/research/srg/netos/papers/2007-cpwl.pdf [提问]

1. 范围查找等价
2. redis的sl层级比二叉平衡树要低很多，源码中SKIPLIST_P用的是0.25，层次数期望值相当于四叉平衡树

3. skip list 是 Concurrency-Friendly，Non-Blocking



> 看c++怎么实现的？原子操作和顺序一致性 对比
>
>  C++ Concurrency in Action
>
> 位置：第一本书:c++ 11 必读书籍 Effective Modern C++





> 看 文章自己写的

-  Choose Concurrency-Friendly Data Structures（翻译）
- [Effective Concurrency: Choose Concurrency-Friendly Data Structures](https://herbsutter.com/2008/06/27/effective-concurrency-choose-concurrency-friendly-data-structures/)
- https://programmerclick.com/article/70581257539/



1. To illustrate, let's consider two common data structures: linked lists and balanced trees.

~~~
So red-black trees cause some problems for concurrent code:

It's hard to run updates truly concurrently because updates arbitrarily far apart in the tree can touch the same nodes—especially the root, but also other higher-level nodes to lesser degrees—and therefore contend with each other. We have lost the ability to make truly localized changes.

The tree performs extra internal housekeeping writes. This increases the amount of shared data that needs to be written and synchronized across caches to publish what would be a small update in another data structure.

所以红黑树给并发代码带来了一些问题：
很难真正同时运行更新，因为在树中任意相隔很远的更新可能会触及相同的节点——尤其是根，但也会触及其他更高级别的节点，但程度较低——因此会相互竞争。 我们已经失去了进行真正本地化更改的能力。
树执行额外的内部管理写入。 这增加了需要跨缓存写入和同步的共享数据量，以发布另一个数据结构中的小更新
~~~



 









